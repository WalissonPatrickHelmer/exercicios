
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Nível 10 - Assincronicidade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'], },
                    colors: { 'py-dark': '#1F2937', 'py-blue': '#3B82F6', 'py-accent': '#FDE047', 'py-light': '#F9FAFB', 'py-card': '#FFFFFF', }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        .code-block { background-color: #f1f5f9; color: #1e40af; padding: 0.75rem; border-radius: 0.5rem; margin-top: 0.75rem; overflow-x: auto; font-family: monospace; }
        .accordion-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; padding: 0 1.5rem; }
        .accordion-item[open] .accordion-content { max-height: 1000px; padding: 1rem 1.5rem 1.5rem 1.5rem; }
        .accordion-header { cursor: pointer; }
    </style>
</head>
<body class="bg-py-light font-sans">
    <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center py-8 bg-py-dark text-py-light rounded-2xl shadow-xl mb-8">
            <h1 class="text-4xl font-extrabold tracking-tight sm:text-5xl">
                ⚡ NÍVEL 10 – Assincronicidade e Concorrência
            </h1>
        </header>
        <section class="space-y-4">
            
            <!-- Tópico 1: Conceitos de Bloqueio vs. Não-Bloqueio -->
            <details class="accordion-item bg-py-card shadow-lg rounded-xl overflow-hidden ring-1 ring-py-blue/10" open>
                <summary class="accordion-header flex justify-between items-center p-6 bg-py-blue text-py-light font-semibold text-xl rounded-t-xl hover:bg-py-blue/90 transition duration-150">
                    <span class="flex items-center"><span class="text-py-accent mr-3">1.</span> Conceitos de Bloqueio vs. Não-Bloqueio</span>
                </summary>
                <div class="accordion-content">
                    <h3 class="font-bold text-py-dark mb-2 text-lg">Bloqueio (Blocking)</h3>
                    <p class="text-gray-700 mb-2 ml-4">
                        Quando uma função deve completar sua tarefa (Ex: esperar por uma requisição de rede) antes que o fluxo de execução passe para a próxima linha. Isso "bloqueia" o programa.
                    </p>
                    <h3 class="font-bold text-py-dark mb-2 text-lg">Não-Bloqueio (Non-Blocking / Assíncrono)</h3>
                    <p class="text-gray-700 mb-4 ml-4">
                        Permite que o programa comece uma tarefa (Ex: buscar dados), continue executando outras tarefas, e volte para a primeira quando ela estiver pronta, otimizando o tempo de espera.
                    </p>
                </div>
            </details>

            <!-- Tópico 2: Introdução a async e await (Asyncio) -->
            <details class="accordion-item bg-py-card shadow-lg rounded-xl overflow-hidden ring-1 ring-py-blue/10">
                <summary class="accordion-header flex justify-between items-center p-6 bg-py-blue text-py-light font-semibold text-xl rounded-t-xl hover:bg-py-blue/90 transition duration-150">
                    <span class="flex items-center"><span class="text-py-accent mr-3">2.</span> Introdução a async e await (Asyncio)</span>
                </summary>
                <div class="accordion-content">
                    <p class="text-gray-700 mb-4">
                        O módulo **`asyncio`** é o núcleo para programação assíncrona em Python. As palavras-chave **`async`** e **`await`** definem e pausam funções assíncronas.
                    </p>
                    <ul class="list-disc list-inside text-gray-700 space-y-1 ml-4 mb-4">
                        <li>**`async def`**: Define uma função como uma **corrotina** (função assíncrona).</li>
                        <li>**`await`**: Só pode ser usado dentro de uma corrotina e pausa sua execução até que a tarefa assíncrona seja concluída.</li>
                    </ul>
                    <div class="code-block">
                        import asyncio<br>
                        async def main():<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print('Olá')<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;await asyncio.sleep(1) # Pausa por 1 segundo, mas permite outras tarefas<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print('Mundo!')
                    </div>
                </div>
            </details>

            <!-- Tópico 3: Funções e Tarefas Assíncronas -->
            <details class="accordion-item bg-py-card shadow-lg rounded-xl overflow-hidden ring-1 ring-py-blue/10">
                <summary class="accordion-header flex justify-between items-center p-6 bg-py-blue text-py-light font-semibold text-xl rounded-t-xl hover:bg-py-blue/90 transition duration-150">
                    <span class="flex items-center"><span class="text-py-accent mr-3">3.</span> Funções e Tarefas Assíncronas</span>
                </summary>
                <div class="accordion-content">
                    <p class="text-gray-700 mb-4">
                        Corrotinas são executadas dentro de um **loop de eventos** (event loop). O `asyncio.gather()` permite executar múltiplas corrotinas em concorrência.
                    </p>
                    <div class="code-block">
                        async def esperar(tempo):<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;await asyncio.sleep(tempo)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;return f"Esperou {tempo}s"<br>
                        <br>
                        async def executar_varias():<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;# Executa ambas as corrotinas em paralelo<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;resultados = await asyncio.gather(esperar(3), esperar(1))<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print(resultados) # [Esperou 3s, Esperou 1s] (leva cerca de 3s no total)
                    </div>
                </div>
            </details>

            <!-- Tópico 4: Uso de Threads para Concorrência -->
            <details class="accordion-item bg-py-card shadow-lg rounded-xl overflow-hidden ring-1 ring-py-blue/10">
                <summary class="accordion-header flex justify-between items-center p-6 bg-py-blue text-py-light font-semibold text-xl rounded-t-xl hover:bg-py-blue/90 transition duration-150">
                    <span class="flex items-center"><span class="text-py-accent mr-3">4.</span> Uso de Threads para Concorrência</span>
                </summary>
                <div class="accordion-content">
                    <p class="text-gray-700 mb-4">
                        O módulo **`threading`** permite que várias partes do seu programa sejam executadas "simultaneamente" dentro do mesmo processo. Threads são ideais para tarefas ligadas a I/O (entrada/saída), como requisições web ou leitura de arquivos.
                    </p>
                    <p class="text-gray-700 mb-4 font-medium">GIL (Global Interpreter Lock):</p>
                    <p class="text-gray-700 ml-4">
                        Devido ao GIL, Python só executa uma thread por vez (para código puro Python), limitando o paralelismo real em CPUs multi-core.
                    </p>
                </div>
            </details>

            <!-- Tópico 5: Uso de Multiprocessing para Paralelismo -->
            <details class="accordion-item bg-py-card shadow-lg rounded-xl overflow-hidden ring-1 ring-py-blue/10">
                <summary class="accordion-header flex justify-between items-center p-6 bg-py-blue text-py-light font-semibold text-xl rounded-t-xl hover:bg-py-blue/90 transition duration-150">
                    <span class="flex items-center"><span class="text-py-accent mr-3">5.</span> Uso de Multiprocessing para Paralelismo</span>
                </summary>
                <div class="accordion-content">
                    <p class="text-gray-700 mb-4">
                        O módulo **`multiprocessing`** cria novos processos, cada um com seu próprio interpretador Python e espaço de memória. Isso permite o **paralelismo real**, ignorando a restrição do GIL. É ideal para tarefas ligadas à CPU (cálculos pesados).
                    </p>
                    <div class="code-block">
                        from multiprocessing import Process<br>
                        import os<br>
                        <br>
                        def info():<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;print(f"ID do processo: {os.getpid()}")<br>
                        <br>
                        p = Process(target=info)<br>
                        p.start() # Inicia um novo processo
                    </div>
                </div>
            </details>
            
        </section>
        <footer class="text-center mt-10 py-4 text-gray-500 text-sm border-t border-gray-200">
            Fim do Nível 10 – Parabéns por completar o roteiro inicial!
        </footer>
    </div>
</body>
</html>
